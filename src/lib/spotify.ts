interface SpotifyTrack {
  uri: string;
}

interface SpotifyArtistSearch {
  artists: {
    items: { id: string }[];
  };
}

interface SpotifyTopTracks {
  tracks: SpotifyTrack[];
}

// 내부 API 호출 헬퍼
const fetchSpotify = async (endpoint: string, token: string, options: RequestInit = {}) => {
  const res = await fetch(`https://api.spotify.com/v1${endpoint}`, {
    ...options,
    headers: {
      Authorization: `Bearer ${token}`,
      'Content-Type': 'application/json',
      ...options.headers,
    },
  });

  if (!res.ok) {
    const errorData = await res.json();
    throw new Error(errorData.error?.message || 'Spotify API Error');
  }
  return res.json();
};

export interface CreatePlaylistParams {
  artistNames: string[];
  token: string;
  userId: string;
  festivalName?: string; // 선택적 속성이지만 제목에 사용됨
  day?: number;
}

export const createPlaylistFromArtists = async ({ 
  artistNames, 
  token, 
  userId, 
  festivalName,
  day 
}: CreatePlaylistParams) => {
  
  // [수정 포인트 Step 1] 순서 보장을 위한 로직 변경
  // 기존: 각각 비동기로 실행되자마자 배열에 push (순서 섞임)
  // 변경: Promise.all의 반환값(results)은 입력 순서를 보장함
  const results = await Promise.all(
    artistNames.map(async (name) => {
      try {
        // 1. 아티스트 검색
        const searchData = await fetchSpotify(
          `/search?q=${encodeURIComponent(name)}&type=artist&limit=1`, 
          token
        );
        const artist = searchData.artists.items[0];
        
        if (!artist) {
          console.warn(`Artist not found: ${name}`);
          return []; // 없으면 빈 배열 반환
        }

        // 2. 인기곡 검색
        const topTracksData = await fetchSpotify(
          `/artists/${artist.id}/top-tracks?market=KR`, 
          token
        );
        
        // 3. URI 배열 반환
        return topTracksData.tracks.slice(0, 3).map((track: any) => track.uri);

      } catch (e) {
        console.warn(`${name} 처리 중 오류:`, e);
        return []; // 에러 시 빈 배열 반환하여 순서 밀림 방지
      }
    })
  );

  // [중요] 2차원 배열([[uri, uri], [uri, uri], ...])을 1차원으로 평탄화(.flat())
  // Promise.all 덕분에 artistNames의 순서(공연 시간순)가 그대로 유지됨
  const trackUris = results.flat();

  if (trackUris.length === 0) {
    throw new Error("추가할 곡을 찾지 못했습니다.");
  }

  // [Step 2] 플레이리스트 생성 (기존과 동일)
  let playlistTitle = "Wavy Festival Lineup"; 
  if (festivalName) {
    playlistTitle = `[${festivalName}]`;
    if (day) playlistTitle += ` Day ${day}`;
  }

  const playlist = await fetchSpotify(`/users/${userId}/playlists`, token, {
    method: 'POST',
    body: JSON.stringify({
      name: playlistTitle,
      description: `Generated by Wavy. Artists from ${festivalName || 'Festival'} ${day ? `Day ${day}` : ''}. Sorted by performance time.`,
      public: false, 
    }),
  });

  // [Step 3] 곡 추가 (기존과 동일)
  const chunkSize = 100;
  for (let i = 0; i < trackUris.length; i += chunkSize) {
    const chunk = trackUris.slice(i, i + chunkSize);
    await fetchSpotify(`/playlists/${playlist.id}/tracks`, token, {
      method: 'POST',
      body: JSON.stringify({ uris: chunk }), 
    });
  }

  return playlist;
};